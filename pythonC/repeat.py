
from PIL import Image
import pandas as pd
import random
import math
from sklearn.model_selection import train_test_split
import sklearn.svm
import sys
import numpy as np

from ML import rgb2lab
from ML import all_LAB_SVM
from ML import pallete_LAB_cluster
from ML import pallete_LAB
from ML import temp_pallete_RGB

################ RGB 값을 받아와서 그걸로 작업 #######################
#temp_targetData = [[255, 0, 0], [244, 247, 114], [252, 255, 248], [186, 205, 219], [-999, -999, -999], [244, 247, 114], [244, 247, 114], [186, 205, 219], [-999, -999, -999], [244, 247, 114], [-999, -999, -999]]
#처음 255,0,0은 더미 데이터라 저거 넣으면 됨, -999는 빈 영역을 저렇게 표시
#위에 모습처럼 temp_targetData 만들면 됨

#temp_targetData = [[255, 0, 0], [244, 247, 114], [252, 255, 248], [186, 205, 219], [-999, -999, -999], [244, 247, 114], [244, 247, 114], [186, 205, 219], [-999, -999, -999], [244, 247, 114], [-999, -999, -999]]


array = sys.argv[1].split(',')
array1 = list(array)

temp_targetData = np.reshape(array1,(11,3))


################ making LABData #######################

temp_testDataLAB = [[0, 0, 0], [0, 0, 0],[0, 0, 0],[0, 0, 0],[0, 0, 0],[0, 0, 0],[0, 0, 0],[0, 0, 0],[0, 0, 0],[0, 0, 0],[0, 0, 0],]

for i in range(0,11):
    temp_testDataLAB[i][:] = rgb2lab(temp_targetData[i][:])

################### changing to Data Frame ###############

temp  = {'L':[temp_testDataLAB[0][0]],'A':[temp_testDataLAB[0][1]],'B':[temp_testDataLAB[0][2]]}

for i in range(1,11):
  if (temp_testDataLAB[i][0]<0): #없는 값은 다 -999로 대치
    temp['L'].append(-999)
    temp['A'].append(-999)
    temp['B'].append(-999)
  else:
    temp['L'].append(temp_testDataLAB[i][0])
    temp['A'].append(temp_testDataLAB[i][1])
    temp['B'].append(temp_testDataLAB[i][2])

df = pd.DataFrame(data=temp)

temp_testDataLAB = df

target_LAB = temp_testDataLAB.drop(index=0)

################### 타겟 신발의 각 영역의 클러스터 알아보기 #########################

target_LAB_cluster = target_LAB.copy()
temp_cluster = []

for i in range(1,11):
  if -999 == target_LAB.loc[i,'L']:
    #print(i,"는 빈 영역")
    temp_cluster.append(-1)
  else:
    #answer = SVM_area[i].predict(target_LAB)
    answer = all_LAB_SVM.predict(target_LAB)
    temp_cluster.append(answer[i-1])

target_LAB_cluster['cluster'] = temp_cluster

data_LAB_cluster_temp = pd.read_csv(r"C:/Users/cocal/Desktop/Shoes-variation-server/247Linear/Value.csv")

data_LAB_cluster247 = pd.DataFrame(data_LAB_cluster_temp, columns = ['B2','L4','L7','cluster'])

##################################################
data = data_LAB_cluster247.drop(columns=['cluster'])
target = data_LAB_cluster247.drop(columns=['B2', 'L4', 'L7'])


data_LAB_cluster_SVM = sklearn.svm.SVC(C=0.0053, kernel='linear', gamma=0.2) #나중에 최적화 확인하기

cluster_target= pd.DataFrame({'B2':[target_LAB.loc[2,'B']], 'L4':[target_LAB.loc[4,'L']], 'L7':[target_LAB.loc[7,'L']]})
#print(cluster_target)

data_LAB_cluster_SVM.fit(X=data,y=target['cluster'])
cluster_predict_array = data_LAB_cluster_SVM.predict(cluster_target)
cluster_predict = cluster_predict_array[0]

#print(cluster_predict)

#각 영역별 선형회귀 식의 계수
#adjusted R-squared 0.7이상
#2,4,11 유형은 5,6은 그냥 서로만 참조해도 R-squared가 0.9가 넘음

linerRegression2 = [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], # 1L: 절편 + 1영역의 1~10까지의 개수 L,A,B
                    [17.3843,0,0,0,0,1.7844,-1.3547,0,0.3287,0,-0.2584,0,0,0,0,1.5104,0,0,0,-0.6882,0,0,0,0.9332,0,2.1591,-3.3701,0,0,-0.6667,0], 
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [4.9766,0,0,0,0,0,0.9498,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], #L5
                    [-0.9447,0,0,0,0,0.9892,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], #L6
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [51.0319,0,1.2125,0,2.6038,-8.3445,7.0527,-4.1480,0,0.9486,1.5475,0, 1.4757,0,-5.3784,-16.8191,12.7009,2.5590,1.0210,0,-2.4624,0,0,-1.0097,-3.2781,-35.4095,38.2215,0,0,3.5176,0], #L8
                    [38.8960,0.5637,0,0,0,3.5895,-3.3701,0,0,0,-0.2670,0,0,-0.4924,1.5257,7.3057,-6.0547,-0.8154,0,0,0,-0.5038,0,0,0,11.7898,-12.1789,1.0603,0,0,0],
                    [22.9846,0,0,0,0,2.4387,-1.8155,0,0,0,0,0,-1.1057,-1.3837,2.2246,5.9979,-4.2938,-1.4668,0,0,0,-0.3559,0,0.5204,1.3769,10.9440,-11.6872 ,0,0,-0.8476,0], #L10
                    [-2.6984,0,0,0,0,0,-0.2328,0,0,-0.1830,0.5420,0,1.0186,0.7381,0,0,-1.0721,0.7155,-0.5515,0,0.8159,0,0,0,0,0,0,0,0.7888,0,-0.3463], # 1A: 절편 + 1영역의 1~10까지의 개수 L,A,B
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], 
                    [-134.7145,0.2702,0,0,2.5480,1.4557,-1.2935,-0.9934,-0.2579,0,-0.5206,0.7112,-1.2956,0,0,1.1571,0,-0.4867,0.8271,0.2593,-0.7740,-0.4798,-0.4407,0,0,0,0,0.5781,-0.9477,0.5927,0], #A3
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [1.6672,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.7016,0,0,0,0,0,0,0,0,0,0,0,0,0,0], #5A
                    [-1.5544,0,0,0,0,0,0,0,0,0,0,0,0,0.2610,0,0.9542,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], #6A
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [-53.7529,0.2158,0,0.2010,0,0,-0.3077,0.6336,0,-0.3543,0.2251,0,0.5334,0.4978,0,0,0,0,0,0,0.4752,0,0,-0.7292,-0.6762,0.5450,0,0.3198,0,0,0], #A8
                    [-107.8533,0,-0.3569,0,1.4232,1.4130,-1.1920,0,0,0,-0.2755,0,-0.4863,0,0,0.8582,0,0,0.5350,0,0,0,0,0.4050,0,0,-0.6058,0,0,0,0], #A9
                    [-26.3340,0,0.1693,0,1.5203,-1.2972,1.1639,-1.3349,-0.1826,0.2519,0,0.2592,-0.5399,0,-0.8061,-2.7955,2.5729,0,0.5521,0,0,0,0,0,-0.6517,-7.2617,7.6380,0,-0.3325,0.8937,0], #A10
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], # 1B: 절편 + 1영역의 1~10까지의 개수 L,A,B
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], 
                    [3.7502,0,0.3295,0,0,-0.2596,0,0,0,0,0,0,0,0,0,-1.1356,0,0.5022,0,0.4913,0,0,0,0,0,0,0,0.8113,0,0.3422,0.4274], #B3
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [-0.1322,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-0.1560,0,0,0,0,0,0.9829,0,0,0.1374,0], #5B
                    [1.1092,0,0,0,0,0,0,0,0,0,0,0,0,-0.1232,0,0,0,0,0,0,0.1242,0,0,0,0,0.9816,0,0,0,0,0], #6B
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [-156.0369,0.3675,-0.4574,0.1396,1.8307,2.1273,-1.9356,0,0,-0.1937,-0.4140,0.3773,-0.6282,-0.5310,0,1.6162,0,-0.4856,0,0,0,-0.3964,0,0,0,1.9274,-2.3385,0.6399,0,0,0], #B8
                    [137.7395,-0.2757,0,0,-2.5348,-0.8718,0.9116,1.0587,0.1891,0,0.2383,-0.4029,1.0054,0.3702,0.8868,0,-0.8944,0,-0.6790,0,1.0079,0.3045,0.4098,0,0.7752,3.6478,-3.6889,-0.4715,0.8743,0,0], #B9
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]

linerRegression4 = [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], # 1L: 절편 + 1영역의 1~10까지의 개수 L,A,B
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], 
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [12.0404,0,0,0,0,0,0.8544,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], #L5
                    [-6.3914,0,0,0,0,1.0702,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], #L6
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [-2.9690,0,0,0,0,0,0.1524,0,0,-0.1452,0,0,0,0.7356,0,-1.5222,1.5374,0,0.6760,0,0.4313,0,0,0,-0.4233,0,0,0.8640,-0.3899,0,0], # 1A: 절편 + 1영역의 1~10까지의 개수 L,A,B
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], 
                    [-2.1988,-0.1837,0,0,0,0,0,0,0,0.2190,0,0.5567,0,0,0,1.2678,-0.9754,0,-0.4671,0,0,0,0,0,0.5751,0,0,-0.8259,0.3191,0,0], #A3
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0.0693,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.0639,0,0,0,0.1372,0,0,0,0,0,0,0,0,0,0], #5A
                    [0.2367,0,0,0,0,0,0,0,0,0,0,0.1282,0,0,0,0.7932,0,0,0,0,-0.1896,0,0,0,0,0,0,0,0,0,0], #6A
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], # 1B: 절편 + 1영역의 1~10까지의 개수 L,A,B
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], 
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0.1530,0,0,0,0,0,0,0,0,0,0,-0.2189,0,0.3812,0,-0.8752,0.7568,0,0.2291,0,0.1886,0,0,0.1974,0,0,-0.2679,1.0568,-0.3131,0,0], #4B
                    [0.0432,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.9094,0.1527,0,0,0], #5B
                    [0.0885,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.0432,0,-0.1469,0,0,0], #6B
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]

linerRegression11 = [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], # 1L: 절편 + 1영역의 1~10까지의 개수 L,A,B
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], 
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [5.0679,0,0,0,0,0,0.9259,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], #L5
                    [3.2916,0,0,0,0,0.9309,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], #L6
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [87.2549,0,-0.3012,-0.1453,0.3468,-1.0954,1.2042,-0.4413,0,0.1498,0.2814,-0.6169,-0.1191, 0.5367,-0.1464,-0.5483,0.2310,-0.2335,0,0.5298,0,0.3593,0,0,4.1621,-4.3512,0.5750,0,-0.5583,0.2074], #L8
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [-255.3173,0.4379,0.8505,0.4313,0,2.5350,-2.9286,2.1493,0.8757,-0.3981,0,1.7857,0.4129,-1.9240,0.7536,2.3483,-1.0761,0,0,-1.1685,0,0,-1.4959,0,0,-10.6850,11.1505,0,-1.4643,1.0458,0], #L10
                    [166.4257,0,-0.3945,-0.2096,0,-1.7822,1.9521,-1.4477,-0.6901,0.1161,0.4746,0,0,1.0276,-0.4169,-0.7319,0.4128,0,-0.3053,0.8691,-0.2003,0,0.6359,0,0,6.2348,-6.5798,0,0.7045,-0.7883,0.2899], # 1A: 절편 + 1영역의 1~10까지의 개수 L,A,B
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], 
                    [-38.8120,0.3271,0,0,0,0,0,0.4386,0,0,-0.3362,0.5427,0,0,0,0,0.6702,0.5300,-0.3351,-0.3009,0,0.2282,0,0,-0.3296,0,0,0.4089,0,0,0], #A3
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [-48.6340,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.8465,0,0,0,0,0,0,0,0,0,0,0,0,0,0], #5A
                    [34.9774,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.2235,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], #6A
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [-0.2832,0,0,0,0,0,0,0,0,0,0,0,-0.3229,0,0,0.5481,0,0.5512,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [-237.7026,0.3084,0.3844,0,-1.4378,1.6306,-1.6247,3.3293,1.0367,0,-0.7162,0.9529,-0.6530,-1.8937,-1.1826,-1.3563,1.9381,2.1002,0,0,0.9406,0.3374,0,0.6046,-0.6922,-4.7572,4.7722,1.7075,-0.8353,0,-0.5580], #A9
                    [-17.7027,0,0.2824,0.4224,1.7784,1.3494,-1.8185,-1.2281,-0.3728,-0.3368,0,0.7983,0.8025,0,1.8818,3.4908,-2.5257,-1.9447,0,-0.4046,0,0,-1.6335,-0.8404,0.7591,-6.3060,6.9715,-1.7317,0,1.0680,0], #A10
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], # 1B: 절편 + 1영역의 1~10까지의 개수 L,A,B
                    [-11.1459,0,0,0,0.8233,0,0,-0.6852,0,0,0,0,0,0,0.6587,0.7411,-0.7299,-0.5976,0,0,0,0,0,-0.1995,0.2561,-1.1384,1.2662,0,0,0,0], # B2
                    [14.0004,0,-0.3686,0,2.3245,0,0,-1.6675,-0.6678,0.3255,0,0,0,0,1.3420,1.6080,-1.8578,-1.1139,-0.4589,0,0,0,0,0,0.4208,0,0.4704,-0.9539,0.9306,0,0.4538], #B3
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [-14.8665,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1.0302,0,0,0,0], #5B
                    [3.0718,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0.9937,0,0,0,0,0], #6B
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                    [-3.3142,0,0.4630,0.4004,0,1.3146,-1.7300,0,0,-0.6291,0,0.6217,0.7961,0,1.0070,2.5584,-1.5500,-1.1792,0,0,-0.8550,0,-1.2620,0,0.4602,-5.9982,6.0595,-1.1846,0,1.1661,0], #B8
                    [-11.5624,0.1382,0,0,0,-0.4324,0.5285,0,0,0,0,-0.4001,0,0,-0.4567,0,0,0.2835,0,0,0.3435,0,0,0,0,0,0,0.7525,0,0,0], #B9
                    [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],]

linerRegressionOther = [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [7.3497,0,0,0,0,0,0.9066,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], #L5
                        [0.7862,0,0,0,0,0.9696,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], #L6
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0.7393,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.8719,0,0,0,0,0,0,0,0,0,0,0,0,0,0], #A5
                        [-0.0359,0,0,0,0,0,0,0,0,0,0,0,0,0.1188,0,0.8577,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], #A6
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [-2.7517,0,0.0453,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0680,0,-0.1157,0,0,0.9770,0,0,0.0939,0], #B5
                        [-0.3327,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.1417,0,0.8783,0,0,0,-0.0767,0], #B6
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
                        [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]

if cluster_predict == 2:
  linerRegressionTarget = linerRegression2.copy()
elif cluster_predict == 4:
  linerRegressionTarget = linerRegression4.copy()
elif cluster_predict == 11:
  linerRegressionTarget = linerRegression11.copy()
else:
  linerRegressionTarget = linerRegressionOther.copy()

same = False #학습 전후의 DF이 같으면 same은 True
target_LAB_temp = target_LAB.copy()

while same == False:
  
  target_LAB = target_LAB_temp.copy() #학습을 했는데 무언가 바뀐게 있으면 바뀐거로 다시 학습하고 또 달라지는게 있는지 확인하기
  target_LAB_temp = target_LAB.copy()

  for row in range(10):
    for col in range(3):
      if target_LAB_temp.iloc[row,col] == -999: #비어있다.
        #print(row+1,"영역의",col,"값 비어있음")
        predict = 0
        for area in range(1,31): #식에 곱할 인자: L1 = L2*"3.5" + ... / L1,L2,L3, ... B9,B10
          if area%10 == 0:
            targetRow = 9
            targetCol = (area//10)-1
          else:
            targetRow = (area%10)-1
            targetCol = area//10
          
          #print("linerRegressionTarget의",(col*10)+row,"행",area,"열 * target_LAB의",targetRow+1,"영역에",targetCol)
          if (linerRegressionTarget[(col*10)+row][area]!=0) and (target_LAB.iloc[targetRow,targetCol] == -999): #회귀식의 인자가 0이 아닌데 즉, 필요한 값인데 없으면(-999면)
            #print(targetRow,"영역의",targetCol,"열 의 값이 없음")
            predict = -999
            break
          else:
            #if linerRegressionTarget[(col*10)+row][area] != 0:
              #print("+",linerRegressionTarget[(col*10)+row][area],"*",target_LAB.iloc[targetRow,targetCol])
            #print((col*10)+row,area,targetRow,targetCol)
            predict += linerRegressionTarget[(col*10)+row][area] * target_LAB.iloc[targetRow,targetCol]
        if (predict == 0) or (predict == -999):
          predict = -999
        else:
          predict += linerRegressionTarget[(col*10)+row][0]
        #print(predict)
        target_LAB_temp.iloc[row,col] = predict
  
  #두개의 데이터 프레임이 같으면 same을 True로 변경
  breaker = False
  for row in range(10):
    for col in range(3):
      if target_LAB.iloc[row,col] == target_LAB_temp.iloc[row,col]:
        same = True
      else:
        same = False
        #print("two dataframe is different")
        breaker = True
        break
    if breaker == True: #이중 for문 탈출을 위한 구문
      break

############# 각 유형별 영역의 범위 #######################
cluster_range = [[(-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-15,15), (-999,-999),(-999,-999),(-999,-999), #0유형 L1
                  (85,100),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999), #0유형 L4
                  (65,80),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999), #0유형 L7
                  (-999,-999),(-999,-999),(-999,-999)], #1유형 L10
                 [(-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(0,20), (-999,-999),(-999,-999),(-999,-999),
                  (50,60),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999),
                  (40,70),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999),
                  (-999,-999),(-999,-999),(-999,-999)],
                 [(-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-40,0), (-999,-999),(-999,-999),(-999,-999),
                  (85,100),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999),
                  (85,100),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999),
                  (-999,-999),(-999,-999),(-999,-999)],
                 [(-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-40,0), (-999,-999),(-999,-999),(-999,-999),
                  (40,50),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999),
                  (30,50),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999),
                  (-999,-999),(-999,-999),(-999,-999)],
                 [(-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-10,10), (-999,-999),(-999,-999),(-999,-999),
                  (70,90),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999),
                  (80,100),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999),
                  (-999,-999),(-999,-999),(-999,-999)],
                 [(30,50),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-20,0), (-999,-999),(-999,-999),(-999,-999), #5유형
                  (80,100),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999), (-999,-999),(-10,10),(-999,-999),
                  (25,45),(-999,-999),(-999,-999), (-999,-999),(-10,20),(-999,-999), (-999,-999),(-999,-999),(-999,-999),
                  (-999,-999),(-10,20),(-999,-999)],
                 [(-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(0,50), (-999,-999),(-999,-999),(-999,-999), #6유형
                  (85,100),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999),
                  (80,100),(-999,-999),(-999,-999), (80,100),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999),
                  (-999,-999),(-999,-999),(-999,-999)],
                 [(-999,-999),(-999,-999),(-999,-999), (-999,-999),(0,50),(30,50), (-999,-999),(-999,-999),(-999,-999),
                  (60,90),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999),
                  (40,70),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999),
                  (-999,-999),(-999,-999),(-999,-999)],
                 [(-999,-999),(-999,-999),(-999,-999), (-999,-999),(-25,25),(-15,15), (-999,-999),(-999,-999),(-999,-999), #8유형
                  (10,40),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-20,20), (-999,-999),(-999,-999),(-20,20),
                  (10,40),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999),
                  (-999,-999),(-999,-999),(-999,-999)],
                 [(-999,-999),(-999,-999),(-999,-999), (80,100),(-20,10),(30,55), (80,100),(-999,-999),(-999,-999),
                  (35,40),(0,10),(-5,10), (-999,-999),(-999,-999),(-999,-999), (-999,-999),(-30,5),(10,30),
                  (90,100),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999),
                  (-999,-999),(-999,-999),(-999,-999)],
                 [(60,90),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-10,0), (60,100),(-10,15),(-30,0), #10유형
                  (20,50),(-30,10),(-10,10), (-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999),
                  (80,90),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-20,10), (-999,-999),(-999,-999),(-999,-999),
                  (-999,-999),(-999,-999),(-999,-999)],
                 [(-999,-999),(-999,-999),(-999,-999), (-999,-999),(-40,30),(-30,10), (-999,-999),(-999,-999),(-999,-999),
                  (60,80),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999),
                  (65,95),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999),
                  (-999,-999),(-999,-999),(-999,-999)],
                 [(-999,-999),(-999,-999),(-20,30), (-999,-999),(-999,-999),(-10,30), (-999,-999),(-999,-999),(-999,-999),
                  (75,95),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999),
                  (50,70),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999),
                  (-999,-999),(-999,-999),(-999,-999)],
                 [(20,30),(-999,-999),(-999,-999), (60,75),(5,45),(40,50), (60,70),(-999,-999),(-999,-999),
                  (20,40),(-999,-999),(-999,-999), (-999,-999),(0,10),(-10,0), (-999,-999),(-999,-999),(-10,10),
                  (20,30),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999), (60,70),(-20,0),(-10,5),
                  (25,30),(-15,5),(-15,5)],
                 [(70,90),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(0,30), (-999,-999),(-999,-999),(-999,-999), #14유형
                  (50,80),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999),
                  (70,90),(-999,-999),(-999,-999), (70,90),(-999,-999),(-999,-999), (-999,-999),(-999,-999),(-999,-999),
                  (-999,-999),(-999,-999),(-999,-999)]
                ]

################### 팔레트 고르기 #########################

temp = {'score':[0]} #각 컬러 팔레트의 점수
for i in range(1,119):
  temp['score'].append(0)

pallete_score = pd.DataFrame(data=temp) #각 컬러 팔레트의 점수
pallete_score.index +=1

for palleteNum in range(1,120): #팔레트
  #print("------------------------",palleteNum,"------------------------")
  for targetArea in range(1,11): #각 영역 돌기
    if (target_LAB.loc[targetArea,'L'] < -900) and (target_LAB.loc[targetArea,'A'] < -900) and (target_LAB.loc[targetArea,'B'] < -900): #empty area
      #print(targetArea,"는 비어 있는 영역")
      temp_rangeOfLABinArea = [] #해당 유형에 해당 영역의 LAB값의 (시작점,끝점): [(-999,-999),(-999,-999),(-10,30)]
      temp_rangeOfLABinArea.append(cluster_range[cluster_predict][targetArea*3-3]) #L값
      temp_rangeOfLABinArea.append(cluster_range[cluster_predict][targetArea*3-2]) #A값
      temp_rangeOfLABinArea.append(cluster_range[cluster_predict][targetArea*3-1]) #B값

      if temp_rangeOfLABinArea == [(-999,-999),(-999,-999),(-999,-999)]: #유형으로 범위를 유추할 수 없다면..
        #print(targetArea, "는 정보가 없어서 pass")
        continue
      else: #만약, 유형으로 범위를 유추할 수 있다면 해당 범위에 해당하는 색이 있는지 확인하기
        #print(targetArea,"는 유추 가능한 영역")
        tempMin = 1000
        for colorNum in range((palleteNum-1)*6+1,(palleteNum-1)*6+7): #각 팔래트 위의 색
          Lswitch,Aswitch,Bswitch = False, False, False #해당 범위에 돌고있는 팔레트의 색의 L,A,B가 속하는지: 속하거나 LAB의 기준이 없으면 True 아니면 False
          if (temp_rangeOfLABinArea[0][0] <= pallete_LAB.loc[colorNum,'L'] <= temp_rangeOfLABinArea[0][1]) or (temp_rangeOfLABinArea[0] == (-999,-999)): #L값
            Lswitch=True
          if (temp_rangeOfLABinArea[1][0] <= pallete_LAB.loc[colorNum,'A'] <= temp_rangeOfLABinArea[1][1]) or (temp_rangeOfLABinArea[1] == (-999,-999)): #A값
            Aswitch=True
          if (temp_rangeOfLABinArea[2][0] <= pallete_LAB.loc[colorNum,'B'] <= temp_rangeOfLABinArea[2][1]) or (temp_rangeOfLABinArea[2] == (-999,-999)): #B값
            Bswitch=True
          
          if (Lswitch==True) and (Aswitch==True) and (Bswitch==True): #지정된 색이 해당 범위를 만족함
            #print("이 팔레트에는 조건을 만족하는 색이 있네요!")
            tempMin = 0
            break #해당 팔레트에 만족하는 색이 있으면 더이상 패널티를 부여할 필요가 없기 때문에 그냥 나옴
        pallete_score.loc[palleteNum,'score'] += tempMin

    else: #empty area가 아님 / L,A,B중 일부만 값을 아는건 어쩔거임??(10/01) 나누자
      tempMin = 1000
      for colorNum in range((palleteNum-1)*6+1,(palleteNum-1)*6+7): #각 팔래트 위의 색
        #if (target_LAB_cluster.loc[targetArea,'cluster'] != pallete_LAB_cluster.loc[colorNum, 'cluster'] and target_LAB_cluster.loc[targetArea,'cluster'] != -1): # + 일부 값만 예측하면 그것에 클러스터를 배정하는 것이 옳은가?
        if (target_LAB_cluster.loc[targetArea,'cluster'] != pallete_LAB_cluster.loc[colorNum, 'cluster']): #만약 너무 다르다면 즉, 같은 클러스터에도 없다면 그냥 건너뛴다.
          continue
        #print(targetArea,"영역의 색이랑",colorNum,"번째 색이랑 같은 클러스터")
        temp_color_distance = 0
        if pallete_LAB.loc[colorNum,'L'] > -990: #L값이 있을 때
          temp_color_distance += ((pallete_LAB.loc[colorNum,'L']-target_LAB.loc[targetArea,'L'])**2)
        if pallete_LAB.loc[colorNum,'A'] > -990: #A값이 있을 때
          temp_color_distance += ((pallete_LAB.loc[colorNum,'A']-target_LAB.loc[targetArea,'A'])**2)
        if pallete_LAB.loc[colorNum,'B'] > -990: #B값이 있을 때
          temp_color_distance += ((pallete_LAB.loc[colorNum,'B']-target_LAB.loc[targetArea,'B'])**2)
        temp_color_distance = math.sqrt(temp_color_distance)
        if temp_color_distance == 0: #만약 다 -999면 1000
          temp_color_distance = 1000
        #temp_color_distance = math.sqrt(((pallete_LAB.loc[colorNum,'L']-target_LAB.loc[targetArea,'L'])**2)+((pallete_LAB.loc[colorNum,'A']-target_LAB.loc[targetArea,'A'])**2)+((pallete_LAB.loc[colorNum,'B']-target_LAB.loc[targetArea,'B'])**2))
        #print(colorNum, "번째 색이랑", targetArea,"번째 영역 비교: 차이는", temp_color_distance)
        if tempMin > temp_color_distance:
          tempMin = temp_color_distance
      #print(targetArea, "영역에서 가장 비슷한 색과의 거리는", tempMin)
    pallete_score.loc[palleteNum,'score'] += tempMin #이거는 영역 갯수에 가중치가 있음

recommend_palleteNum = pallete_score.idxmin()
#print(recommend_palleteNum['score'], "번 팔레트 추천")
pred_pallete = recommend_palleteNum['score']

#################### 고른 팔레트로 사용자가 칠한 색이랑 가장 가까운색 칠하기 + 빈 영역 유추 ##################

import random

areaCol = [0,0,0,0,0,0,0,0,0,0,0] #각 영역에 몇번째 색이 들어가야하는지
usedColor  = []

for targetArea in [2,4,3,5,6,1,7,8,9,10]: #데이터를 이용한 인접 행렬 만들기
  #print(targetArea, "영역 칠하기")

  if (target_LAB.loc[targetArea,'L'] < -900) and (target_LAB.loc[targetArea,'A'] < -900) and (target_LAB.loc[targetArea,'B'] < -900): #empty area
    #print(targetArea,"는 비어 있는 영역")
    temp_rangeOfLABinArea = [] #해당 유형에 해당 영역의 LAB값의 (시작점,끝점): [(-999,-999),(-999,-999),(-10,30)]
    temp_rangeOfLABinArea.append(cluster_range[cluster_predict][targetArea*3-3]) #L값
    temp_rangeOfLABinArea.append(cluster_range[cluster_predict][targetArea*3-2]) #A값
    temp_rangeOfLABinArea.append(cluster_range[cluster_predict][targetArea*3-1]) #B값

    if temp_rangeOfLABinArea == [(-999,-999),(-999,-999),(-999,-999)]: #유형으로 범위를 유추할 수 없다면..
        #print(targetArea, "는 정보가 없어서 pass")
        continue

    availCol = [] #범위의 조건을 만족하는 색
    for colorNum in range((pred_pallete-1)*6+1,(pred_pallete-1)*6+7): #각 팔래트 위의 색

      Lswitch,Aswitch,Bswitch = False, False, False #해당 범위에 돌고있는 팔레트의 색의 L,A,B가 속하는지: 속하거나 LAB의 기준이 없으면 True 아니면 False
      if (temp_rangeOfLABinArea[0][0] <= pallete_LAB.loc[colorNum,'L'] <= temp_rangeOfLABinArea[0][1]) or (temp_rangeOfLABinArea[0] == (-999,-999)): #L값
        Lswitch=True
      if (temp_rangeOfLABinArea[1][0] <= pallete_LAB.loc[colorNum,'A'] <= temp_rangeOfLABinArea[1][1]) or (temp_rangeOfLABinArea[1] == (-999,-999)): #A값
        Aswitch=True
      if (temp_rangeOfLABinArea[2][0] <= pallete_LAB.loc[colorNum,'B'] <= temp_rangeOfLABinArea[2][1]) or (temp_rangeOfLABinArea[2] == (-999,-999)): #B값
        Bswitch=True
      
      if (Lswitch==True) and (Aswitch==True) and (Bswitch==True): #지정된 색이 해당 범위를 만족함
        #인접 행렬 조건
        if (targetArea == 4) and (colorNum == areaCol[2]):
          continue
        elif (targetArea == 3) and (colorNum == areaCol[4]):
          continue
        elif (targetArea == 5):
          if (colorNum == areaCol[2]) or (colorNum == areaCol[4]):
            continue
        elif (targetArea == 6):
          if (colorNum == areaCol[2]) or (colorNum == areaCol[4]):
            continue
        elif (targetArea == 1) and (colorNum == areaCol[2]):
          continue
        elif (targetArea == 7) and (colorNum == areaCol[2]):
          continue
        elif (targetArea == 8) and (colorNum == areaCol[2]):
          continue
        elif (targetArea == 9) and (colorNum == areaCol[8]):
          continue
        elif (targetArea == 10) and (colorNum == areaCol[9]):
          continue
        availCol.append(colorNum)
    
    #print(availCol)
    if availCol != []:
      #print(targetArea, "에 가능한 색은",availCol)
      areaCol[targetArea] = random.choice(availCol)

  else: #not empty area
    min_distance = 1000

    for colorNum in range((pred_pallete-1)*6+1,(pred_pallete-1)*6+7):

      #인접 행렬 조건
      if (targetArea == 4) and (colorNum == areaCol[2]):
        continue
      elif (targetArea == 3) and (colorNum == areaCol[4]):
        continue
      elif (targetArea == 5):
        if (colorNum == areaCol[2]) or (colorNum == areaCol[4]):
          continue
      elif (targetArea == 6):
        if (colorNum == areaCol[2]) or (colorNum == areaCol[4]):
          continue
      elif (targetArea == 1) and (colorNum == areaCol[2]):
        continue
      elif (targetArea == 7) and (colorNum == areaCol[2]):
        continue
      elif (targetArea == 8) and (colorNum == areaCol[2]):
        continue
      elif (targetArea == 9) and (colorNum == areaCol[8]):
        continue
      elif (targetArea == 10) and (colorNum == areaCol[9]):
        continue

      temp_color_distance = 0

      if pallete_LAB.loc[colorNum,'L'] > -990: #L값이 있을 때
        temp_color_distance += ((pallete_LAB.loc[colorNum,'L']-target_LAB.loc[targetArea,'L'])**2)
      if pallete_LAB.loc[colorNum,'A'] > -990: #A값이 있을 때
        temp_color_distance += ((pallete_LAB.loc[colorNum,'A']-target_LAB.loc[targetArea,'A'])**2)
      if pallete_LAB.loc[colorNum,'B'] > -990: #B값이 있을 때
        temp_color_distance += ((pallete_LAB.loc[colorNum,'B']-target_LAB.loc[targetArea,'B'])**2)
      temp_color_distance = math.sqrt(temp_color_distance)
      if temp_color_distance == 0: #만약 다 -999면 1000
        temp_color_distance = 1000
      
      if temp_color_distance < min_distance:
        min_distance = temp_color_distance
        areaCol[targetArea] = colorNum
        
    usedColor.append(areaCol[targetArea])
    #palleteCluster[colorNum] = -1 #사용한 색은 클러스터를 -1로 바꿈

#print("정할 수 있었던 색: ", areaCol)

###############만약 그럼에도 불구하고 정하기 못한 영역이 있다면 랜덤으로 넣기 ################
selCol = list()

palleteColor = list(range((pred_pallete-1)*6+1,(pred_pallete-1)*6+7))

#print("used Color:", usedColor)

unUsedColor = list(set(palleteColor) - set(usedColor))
#print("unused Color:",unUsedColor )

for targetArea in range(1,11):
  #print(targetArea)
  if areaCol[targetArea] == 0: #비어 있는 영역을 발견
    
    if targetArea == 6:
      areaCol[targetArea] = areaCol[5]
      #print(targetArea, "영역은",areaCol[5],"색 할당")
      continue
    
    if unUsedColor == []: #만약 모든 색을 다 썼으면
      candidateColor = []
      for colorNum in range((pred_pallete-1)*6+1,(pred_pallete-1)*6+7):
      #인접 행렬 조건
        if (targetArea == 4) and (colorNum == areaCol[2]):
          continue
        elif (targetArea == 3) and (colorNum == areaCol[4]):
          continue
        elif (targetArea == 5):
          if (colorNum == areaCol[2]) or (colorNum == areaCol[4]):
            continue
        elif (targetArea == 6):
          if (colorNum == areaCol[2]) or (colorNum == areaCol[4]):
            continue
        elif (targetArea == 1) and (colorNum == areaCol[2]):
          continue
        elif (targetArea == 7) and (colorNum == areaCol[2]):
          continue
        elif (targetArea == 8) and (colorNum == areaCol[2]):
          continue
        elif (targetArea == 9) and (colorNum == areaCol[8]):
          continue
        elif (targetArea == 10) and (colorNum == areaCol[9]):
          continue
        candidateColor.append(colorNum)

      areaCol[targetArea] = random.choice(candidateColor)
    
    else: #안썼으면 안쓴색 쓰기
      areaCol[targetArea] = random.choice(unUsedColor)
      unUsedColor.remove(areaCol[targetArea])
      #print(targetArea, "영역은",areaCol[targetArea],"색 할당")

#print(areaCol)

###################### 각 영역의 RGB 값 출력############################

areaRGB = [(0,0,0)]

for i in range(1,11):
  num = areaCol[i]
  
  palleteNum = (num//6)+1
  if num%6==0:
    palleteNum = num//6
  
  colorNum = num%6
  if colorNum == 0:
    colorNum = 6
  
  areaRGB.append(temp_pallete_RGB[palleteNum][colorNum])

print(areaRGB)